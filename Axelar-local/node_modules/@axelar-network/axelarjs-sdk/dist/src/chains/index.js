"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.importChains = exports.loadChains = void 0;
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const assets_1 = require("../assets");
const clone_deep_1 = __importDefault(require("clone-deep"));
function loadChains(config) {
    return __awaiter(this, void 0, void 0, function* () {
        const allAssets = yield (0, assets_1.loadAssets)(config);
        const _environment = config.environment;
        const rawChains = yield importChains({ environment: _environment });
        /*push assets to supported chains*/
        rawChains.forEach((chainInfo) => {
            const filteredAssetList = allAssets.filter(({ chain_aliases }) => Object.keys(chain_aliases).indexOf(chainInfo.chainName.toLowerCase()) > -1);
            const assetsList = [];
            filteredAssetList.forEach((asset) => {
                const assetToPush = (0, clone_deep_1.default)(asset.chain_aliases[chainInfo.chainName.toLowerCase()]);
                assetToPush.common_key = asset.common_key[_environment];
                assetToPush.native_chain = asset.native_chain;
                assetToPush.decimals = asset.decimals;
                assetToPush.fullySupported = asset.fully_supported;
                assetsList.push(assetToPush);
            });
            chainInfo.assets = assetsList;
        });
        return rawChains;
    });
}
exports.loadChains = loadChains;
const urlMap = {
    devnet: "https://axelar-testnet.s3.us-east-2.amazonaws.com/devnet-chain-config.json",
    testnet: "https://axelar-testnet.s3.us-east-2.amazonaws.com/testnet-chain-config.json",
    mainnet: "https://axelar-mainnet.s3.us-east-2.amazonaws.com/mainnet-chain-config.json",
};
const chainMap = { devnet: null, testnet: null, mainnet: null };
function importChains(config) {
    return __awaiter(this, void 0, void 0, function* () {
        if (chainMap[config.environment])
            return Object.values(chainMap[config.environment]);
        chainMap[config.environment] = yield execGet(urlMap[config.environment]);
        return Object.values(chainMap[config.environment]);
    });
}
exports.importChains = importChains;
function execGet(url) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0, cross_fetch_1.default)(url, {
            method: "GET",
            headers: { "Content-Type": "application/json" },
        })
            .then((res) => res.json())
            .catch((error) => {
            throw error;
        });
    });
}
//# sourceMappingURL=index.js.map